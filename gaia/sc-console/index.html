<html>

<head>
  <title>Contract Interface</title>
  <script src="./js/main.js"></script>
  <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
    crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut"
    crossorigin="anonymous"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/js/bootstrap.min.js" integrity="sha384-B0UglyR+jN6CkvvICOB2joaf5I4l3gm9GU6Hc1og6Ls7i6U/mkkaduKaBhlAXv9k"
    crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" integrity="sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS"
    crossorigin="anonymous">
</head>

<body>
  <div id="alertBox" style="position: fixed; bottom: 20px; left: 20px; min-width: 500px; z-index: 1000;"></div>
  <div class="container-fluid">
    <div class="row">
      <div class="col-12" style="padding: 20px;">
        <h2 class="text-info">RealStake - Smart Contracts Console v1.0.5</h2>
      </div>
      <div class="col-2">
        <div id="list-example" class="list-group">
          <a class="list-group-item list-group-item-action" href="#account-info">Account Dashboard</a>
          <a class="list-group-item list-group-item-action" href="#token-info">Token Dashboard</a>
          <a class="list-group-item list-group-item-action" href="#tokenize-property">Tokenize Property</a>
          <a class="list-group-item list-group-item-action" href="#whitelist-manager">Whitelist Manager</a>
          <a class="list-group-item list-group-item-action" href="#offer-list">Offer List</a>
          <!--
          <a class="list-group-item list-group-item-action" href="#primary-sale">Primary Sale</a>
          <a class="list-group-item list-group-item-action" href="#list-item-4">Item 4</a>
          <a class="list-group-item list-group-item-action" href="#list-item-4">Item 4</a>
          <a class="list-group-item list-group-item-action" href="#list-item-4">Item 4</a>
          <a class="list-group-item list-group-item-action" href="#list-item-4">Item 4</a>
          <a class="list-group-item list-group-item-action" href="#list-item-4">Item 4</a>
          -->
        </div>
      </div>
      <div class="col-10">

        <!-- Begin account info -->
        <div class="form-group" id="account-info">
          <h3>Account Dashboard</h3>
          <div class="text-center">
            <h5 id="accountAddress">-</h5>
            <h3 id="accountBalance">-</h3>
            <h6 id="networkInfo">-</h6>
          </div>
          <hr />
          <div class="input-group mb-3">
            <div class="input-group-prepend">
              <span class="input-group-text">Select network</span>
            </div>
            <select id="optNetwork" class="form-control">
              <option value="rinkeby-develop" selected>Rinkeby develop</option>
              <option value="rinkeby-staging">Rinkeby staging</option>
            </select>
            <div class="input-group-append">
              <button class="btn btn-primary" id="btnConnectWallet">Connect Wallet</button>
            </div>
          </div>
        </div>
        <!-- End account info -->

        <!-- Begin token info -->
        <div class="form-group" id="token-info">
          <h3>Token Info</h3>
          <div class="text-center">
            <h5>Stable Coin Balance</h5>
            <h3 id="stableCoinBalance">-</h3>
          </div>
          <hr />
          <div class="input-group mb-3">
            <div class="input-group-prepend">
              <span class="input-group-text">Property Token's address</span>
            </div>
            <input type="text" class="form-control" id="textPropertyTokenAddress" autocomplete="off">
            <div class="input-group-append">
              <button class="btn btn-success" id="btnAddTokenToWatch">Add To Watch</button>
              <button class="btn btn-primary" id="btnReloadToken">Refresh</button>
            </div>
          </div>
          <table class="table">
            <thead>
              <tr>
                <th scope="col">#</th>
                <th scope="col">Token address</th>
                <th scope="col">Balance</th>
                <th scope="col">Action</th>
              </tr>
            </thead>
            <tbody id="tableTokenWatchBody"></tbody>
          </table>
        </div>
        <!-- End token info -->

        <!-- Begin deploy property token -->
        <div class="form-group" id="tokenize-property">
          <h3>Property Tokenize</h3>
          <label>Owner account:</label>
          <input type="text" class="form-control" id="textTokenOwner"><br />
          <button class="btn btn-primary" id="btnDeployPropertyToken">Deploy property token</button><br /><br />
          <table class="table">
            <thead>
              <tr>
                <th scope="col">#</th>
                <th scope="col">Address</th>
                <th scope="col">Owner Address</th>
                <th scope="col">Whitelisted</th>
              </tr>
            </thead>
            <tbody id="tableTokenizedProperty"></tbody>
          </table>
        </div>
        <!-- End deploy property token -->

        <!-- Begin whitelist manager -->
        <div class="form-group" id="whitelist-manager">
          <h3>Whitelist</h3>
          <label>Unique name:</label><br />
          <input type="text" class="form-control" id="textName"><br />
          <label>Address to white list:</label><br />
          <input type="text" class="form-control" id="textAddress"><br />
          <button class="btn btn-success" id="btnAddToWhitelist">Add to Whitelist</button>
          <button class="btn btn-warning" id="btnWhitelistRefresh">Refresh</button><br /> <br />
          <table class="table">
            <thead>
              <tr>
                <th scope="col">#</th>
                <th scope="col">Name</th>
                <th scope="col">Address</th>
                <th scope="col">Verified</th>
              </tr>
            </thead>
            <tbody id="tableWhitelistBody"></tbody>
          </table>
        </div>
        <!-- End whitelist manager -->

        <!-- Begin whitelist manager -->
        <div class="form-group" id="offer-list">
          <button class="btn btn-warning" id="btnOfferListRefresh">Offer List Refresh</button><br /><br />
          <table class="table">
            <thead>
              <tr>
                <th scope="col">#</th>
                <th scope="col">Token</th>
                <th scope="col">Maker</th>
                <th scope="col">Price</th>
                <th scope="col">Amount</th>
                <th scope="col">Expired</th>
                <th scope="col">Minimum</th>
              </tr>
            </thead>
            <tbody id="tableOfferList"></tbody>
          </table>
        </div>
        <!-- End whitelist manager -->

        <div class="form-group" id="primary-sale">
          <h3>Start Primary Sale</h3>
          <label>PropertyToken address:</label><br />
          <input type="text" class="form-control" id="primarySaleTokenAddress"><br />
          <button class="btn btn-light" onclick="allowInternalTransfer()">Allow Exchange use fund</button>
          <button class="btn btn-light" onclick="startPrimarySale()">Start primary sale</button>
        </div>
        <div class="form-group" id="whitelist-manager"></div>
        <div class="form-group" id="whitelist-manager"></div>
        <div class="form-group" id="whitelist-manager"></div>

      </div>
    </div>
  </div>
  <script type="text/javascript">

    let newInterface = null;

    let storage = {
      set: (key, object) => localStorage.setItem(key, (typeof object === 'string') ? object : JSON.stringify(object)),
      get: (key) => {
        try {
          return JSON.parse(localStorage.getItem(key));
        } catch (e) {
          return localStorage.getItem(key);
        }
      },
      push: function (key, object) {
        let data = this.get(key) || [];
        data.push(object);
        return this.set(key, data);
      }
    };

    function alertNow(type, message) {
      let randomID = (((Math.random() * 0xffffffff) | 0) >>> 0).toString(16);
      $("#alertBox").append(`<div class="alert alert-${type}" id="alert-id-${randomID}" role="alert">${message}</div>`);
      setTimeout(function () {
        $(`#alert-id-${randomID}`).remove();
      }, 5000);
    }

    $(document).ready(() => {
      $('div.form-group').hide();
      $('div#account-info').show();
      if (storage.get('network')) {
        $('#optNetwork').val(storage.get('network'));
        //Trigger connect
        $('#btnConnectWallet').click();
      }
    });

    $('a.list-group-item-action').click(function () {
      let target = 'div' + $(this).attr('href');
      switch (target) {
        case 'div#token-info':
          $('#btnReloadToken').click();
          break;
        case 'div#whitelist-manager':
          $('#btnWhitelistRefresh').click();
          break;
        case 'div#tokenize-property':
          reloadTokenized();
          break;
      }
      $('div.form-group').hide();
      $(target).show();
    });

    $('#btnAddTokenToWatch').click(() => {
      let tokenAddress = $('#textPropertyTokenAddress').val().toLowerCase();
      if (newInterface.utilities.isValidAddress(tokenAddress)) {
        let tokenWatchlist = storage.get('token-watch-list') || [];
        if (tokenWatchlist.indexOf(tokenAddress) < 0) {
          tokenWatchlist.push(tokenAddress);
          storage.set('token-watch-list', tokenWatchlist);
          alertNow('success', 'Added to watching list');
          $('#btnReloadToken').click();
        } else {
          alertNow('warning', 'Duplicated property token address');
        }
      } else {
        alertNow('danger', 'Invalid property token address');
      }
    });

    function reloadTokenized() {
      (async () => {
        let table = $('#tableTokenizedProperty');
        table.find('*').remove();
        let whitelistInstance = newInterface.load('Whitelist');

        let toknized = storage.get('tokenized-property-token') || [];
        for (let i = 0; i < toknized.length; i++) {
          let propertyTokenInstance = newInterface.load('PropertyToken', toknized[i]);
          let verified = await whitelistInstance.sync.verified(toknized[i]);
          table.append(`<tr><th scope="row">${i}</th><td>${toknized[i]}</td><td>${(await propertyTokenInstance.sync.owner())}</td><td>${verified}</td></tr>`);
        }
      })();
    }

    $('#btnReloadToken').click(function () {
      (async () => {
        let table = $('#tableTokenWatchBody');
        table.find('*').remove();
        let tokenWatchlist = storage.get('token-watch-list') || [];
        for (let i = 0; i < tokenWatchlist.length; i++) {
          let propertyTokenInstance = newInterface.load('PropertyToken', tokenWatchlist[i]);
          table.append(`<tr><th scope="row">${i}</th><td>${tokenWatchlist[i]}</td><td>${(await propertyTokenInstance.sync.balanceOf(newInterface.defaultAccount))}</td><td>-</td></tr>`);
        }
      })();
    });

    $('#btnDeployPropertyToken').click(() => {
      if (newInterface === null) return;
      if (!newInterface.utilities.isValidAddress($('#textTokenOwner').val())) {
        alertNow('warning', 'Invalid owner\'s addresss');
        return;
      }
      //Trigger deploy method
      return newInterface.deployPropertyToken(newInterface.defaultAccount, //Deployer
        $('#textTokenOwner').val(), //Owner
        newInterface.utilities.scenarios.PROPERTY_TOKEN_SCENARIO_ALL,
        newInterface.contracts.Whitelist,
        function (err, newPropertyToken) {
          if (!err) {
            if (typeof (newPropertyToken.address) === 'undefined') {
              alertNow('success', 'Deploy PropertyToken in transaction: ' + newPropertyToken.transactionHash.valueOf());
              newInterface.registerTx('checkTokenizeDone', newPropertyToken.transactionHash.valueOf()).watch();
            }
          }
        });
    });

    function syncWhitelist() {
      (async () => {
        if (newInterface !== null) {
          let whitelistAddress = storage.get('whitelist-address') || [];
          let numberOfWhitelisted = newInterface.toBigNumber(whitelistAddress.length);
          let whitelistInstance = newInterface.load('Whitelist');
          let total = await whitelistInstance.sync.totalVerified();
          if (total.gt(numberOfWhitelisted)) {
            let no = newInterface.toBigNumber(numberOfWhitelisted);
            let name = await whitelistInstance.sync.ordering(no);
            let address = await whitelistInstance.sync.addressBook(name);
            let verified = await whitelistInstance.sync.verified(address);
            name = newInterface.utilities.cleanNullBytes(newInterface.utilities.bytesToString(name));
            whitelistAddress.push({
              no: no.valueOf(),
              name: name,
              address: address,
              verified: verified
            });
            storage.set('whitelist-address', whitelistAddress);
          }
        }
        setTimeout(() => {
          syncWhitelist();
        }, 2000)
      })();
    }
    syncWhitelist();

    function syncOfferList() {
      (async () => {
        if (newInterface !== null) {
          let offerList = storage.get('offer-list') || [];
          let offerId = newInterface.toBigNumber(offerList.length);
          let exchangeStableInstance = newInterface.load('ExchangeStable');
          let total = await exchangeStableInstance.sync.totalOffer();
          if (total.gt(offerId)) {
            let offerData = newInterface.parseData('ExchangeStable.offerData', await exchangeStableInstance.sync.offerData(offerId));
            offerList.push({
              no: offerId.valueOf(),
              token: offerData.token,
              maker: offerData.maker,
              amount: offerData.amount.valueOf(),
              expired: (new Date(offerData.expired.mul(1000).toNumber())).toString(),
              minimum: offerData.minimum.valueOf(),
              price: offerData.price.div('1e+18').valueOf()
            });
            storage.set('offer-list', offerList);
          }
        }
        setTimeout(() => {
          syncOfferList();
        }, 2000)
      })();
    }
    syncOfferList();

    $('#optNetwork').change(function () {
      localStorage.clear();
      alertNow('warning', 'Change network to ' + $(this).val());
    });

    $('#btnAddToWhitelist').click(function () {
      if (newInterface === null) return;
      let name = $('#textName').val();
      let address = $('#textAddress').val();
      if (!newInterface.utilities.isValidAddress(address)) {
        alertNow('warning', 'Invalid address to whitelist.');
        return;
      }
      let whitelistInstance = newInterface.load('Whitelist');
      (async function () {
        if (await whitelistInstance.sync.verified(address)) {
          alertNow('warning', 'Address is whitelisted');
          return;
        }
        //Trigger Whitelist.add(bytes32 _name, addres _address);
        whitelistInstance.add(name, address, function (err, transactionHash) {
          if (!err) {
            alertNow('success', 'Add PropertyToken to Whitelist at: ' + transactionHash.valueOf());
            newInterface.registerTx('checkWhitelistDone', transactionHash.valueOf()).watch();
          }
        });
      })();
    });

    $('#btnWhitelistRefresh').click(function () {
      (async () => {
        let table = $('#tableWhitelistBody');
        let whitelistAddress = storage.get('whitelist-address') || [];
        table.find('*').remove();
        for (let i = 0; i < whitelistAddress.length; i++) {
          let record = whitelistAddress[i];
          table.append(`<tr><th scope="row">${record.no}</th><td>${record.name}</td><td>${record.address}</td><td><span class=${record.verified ? 'text-success' : 'text-danger'}>${record.verified}</span></td></tr>`);
        }
      })();
    });

    $('#btnOfferListRefresh').click(function () {
      (async () => {
        let table = $('#tableOfferList');
        let offerData = storage.get('offer-list') || [];
        table.find('*').remove();
        for (let i = 0; i < offerData.length; i++) {
          let record = offerData[i];
          table.append(`<tr>
                <th scope="col">${record.no}</th>
                <td scope="col">${record.token}</td>
                <td scope="col">${record.maker}</td>
                <td scope="col">${record.price}</td>
                <td scope="col">${record.amount}</td>
                <td scope="col">${record.expired}</td>
                <td scope="col">${record.minimum}</td>
              </tr>`);
        }
      })();
    });

    $('#btnConnectWallet').click(function () {
      (async function () {

        //Create new interface of contract
        newInterface = new ContractInterface();
        let network = $('#optNetwork').val() || 'rinkeby-develop';

        //Init Cotract Interface
        let accounts = await newInterface.init(network);
        storage.set('network', network);

        if (accounts.length > 0) {
          console.log('Accounts: ' + JSON.stringify(accounts));
          $('#accountAddress').html(newInterface.defaultAccount);
          $('#networkInfo').html(network === 'rinkeby-staging' ? 'Rinkeby Staging' : 'Rinkeby Develop');
          //Request for balance
          let balance = await newInterface.getBalance(newInterface.defaultAccount);
          if (balance) {
            $('#accountBalance').html(balance.div('1e+18').valueOf() + '<sub>ETH</sub>');
            console.log('Balance in wei: ' + balance.valueOf());
          }
          let stableCoinInstance = newInterface.load('StableCoin');
          let sbcBalance = await stableCoinInstance.sync.balanceOf(newInterface.defaultAccount);
          if (sbcBalance) {
            $("#stableCoinBalance").html(sbcBalance.div('1e+18').valueOf() + '<sub>RUSD</sub>');
          }
        }

        newInterface.registerCallback(function (job, txHash, error, confirmed, result) {
          if (!error) {
            if (confirmed) {
              let events = newInterface.getEvents(result);
              console.log('    was confirmed in block: ' + result.blockNumber + " blockhash: " + result.blockHash);
              console.log('[' + job + '] Transaction ' + result.transactionHash);
              /*
              let txIDs = textListEscrowTransactionID.value
                .split(',')                                              //Split string to array
                .map(it => it.trim())                                    //Trim spaces
                .filter((it, pos, self) => self.indexOf(it) === pos)     //Filter duplicated
                .map(it => newInterface.toBigNumber(it));                //Convert to big integer
              */
              console.log('[DEBUG]', result, events);
              //All job handler
              switch (job) {
                case 'checkTokenizeDone':
                  if (typeof (result.contractAddress) === 'string') {
                    alertNow('success', 'Contract is deployed at ' + result.contractAddress);
                    storage.push('tokenized-property-token', result.contractAddress);
                    reloadTokenized();
                    newInterface.unWatch(result.transactionHash);
                  }
                  break;
                case 'checkWhitelistDone':
                  if (events.filter(i => i.event.contract === 'Whitelist' && i.event.name === 'Add').length > 0) {
                    alertNow('success', ' Event emitted `Whitelist.Add`');
                    newInterface.unWatch(result.transactionHash);
                  }
                  break;
                case 'checkInternalTransfer':
                  (async function () {
                    let propertyTokenInstance = newInterface.load('PropertyToken', primarySaleTokenAddress.value);
                    if (await propertyTokenInstance.sync.allowedInternalTransfer(newInterface.contracts.ExchangeStable)) {
                      alertNow('success', ' Exchange was allowed to move PropertyToken fund.');
                      newInterface.unWatch(result.transactionHash);
                    }
                  })();
                  break;
                case 'checkPrimarySell':
                  if (events.filter(i => i.event.contract === 'ExchangeStable' && i.event.name === 'PrimarySell').length > 0) {
                    alertNow('success', ' Event emitted `ExchangeStable.PrimarySell`');
                    newInterface.unWatch(result.transactionHash);
                  }
                  break;
                case 'checkTakePrimaryAskOffer':
                  if (events.filter(i => i.event.contract === 'ExchangeStable' && i.event.name === 'PrimaryBuy').length > 0) {
                    alertNow('success', ' Event emitted `ExchangeStable.PrimaryBuy`');
                    newInterface.unWatch(result.transactionHash);
                  }
                  break;
                case 'checkAllowExchangeUseStableCoin':
                  (async function () {
                    let stablecoinInstance = newInterface.load('StableCoin');
                    if ((await stablecoinInstance.sync.allowance(newInterface.defaultAccount, newInterface.contracts.ExchangeStable)).gt(0)) {
                      alertNow('success', ' Exchange was allowed to move StableCoin fund.');
                      newInterface.unWatch(result.transactionHash);
                    }
                  })();
                  break;
                case 'checkApproveEscrowTransaction':
                  if (events.filter(i => i.event.contract === 'EscrowPayment' && i.event.name === 'Approve').length > 0) {
                    alertNow('success', ' Event emitted `EscrowPayment.Approve`');
                    newInterface.unWatch(result.transactionHash);
                  }
                  break;
                case 'checkRefundEscrowTransaction':
                  if (events.filter(i => i.event.contract === 'EscrowPayment' && i.event.name === 'Refund').length > 0) {
                    alertNow('success', ' Event emitted `Whitelist.Refund`');
                    newInterface.unWatch(result.transactionHash);
                  }
                  break;
                case 'checkApproveAllEscrowTransaction':
                  if (events.filter(i => i.event.contract === 'EscrowPayment' && i.event.name === 'Approve').length > 0) {
                    alertNow('success', ' Event emitted `EscrowPayment.Approve(' + events.filter(i => i.event.contract === 'EscrowPayment' && i.event.name === 'Approve').length + ') times`');
                    newInterface.unWatch(result.transactionHash);
                  } else {
                    (async () => {
                      let escrowPaymentInstance = newInterface.load('EscrowPayment');
                      if ((await escrowPaymentInstance.sync.pendingTransactions(txIDs[0]))[5]) {
                        alertNow('success', ' trigger `EscrowPayment.ApproveAll`');
                        newInterface.unWatch(result.transactionHash);
                      }
                    })();
                  }
                  break;
                case 'checkRefundAllEscrowTransaction':
                  if (events.filter(i => i.event.contract === 'EscrowPayment' && i.event.name === 'Refund').length > 0) {
                    alertNow('success', ' Event emitted `Whitelist.Refund(' + events.filter(i => i.event.contract === 'EscrowPayment' && i.event.name === 'Refund').length + ') times`');
                    newInterface.unWatch(result.transactionHash);
                  } else {
                    (async () => {
                      let escrowPaymentInstance = newInterface.load('EscrowPayment');
                      if ((await escrowPaymentInstance.sync.pendingTransactions(txIDs[0]))[5]) {
                        alertNow('success', ' trigger `EscrowPayment.RefundAll`');
                        newInterface.unWatch(result.transactionHash);
                      }
                    })();
                  }
                  break;
                case 'checkUnfreezeTransaction':
                  if (events.filter(i => i.event.contract === 'PropertyToken' && i.event.name === 'Unpause').length > 0) {
                    alertNow('success', ' Event emitted `PropertyToken.Unpause`');
                    newInterface.unWatch(result.transactionHash);
                  }
                  break;
              }
            } else {
              console.log('[WAIT] Waitting for transaction: ' + txHash + ' to be mined.');
            }
          }
          else {
            console.log('[REJECTED] Transaction: ' + txHash + ' was not confimed: ' + error.message);
          }
        }).watch();
      })();
    });
  </script>
  <!--
  <hr />
  <h3>Buyer allows exchange to use stable coin (FO)</h3>
  <label>Amount of Stable Coin</label><br />
  <input type="text" class="form-control" id="textAmountStableCoin"><br />
  <button class="btn btn-light" onclick="allowExchangeUseStableCoin()">Delegate stable coin</button>
  <h3>Take Primary Sale Offer (FO)</h3>
  <label>Offer ID</label><br />
  <input type="text" class="form-control" id="textOfferId"><br />
  <label>Amount of Token</label><br />
  <input type="text" class="form-control" id="textAmount" onchange="onChangeAmount()"><br />
  <label>Estimate value:</label> <label id="estimated">$0</label><br />
  <button class="btn btn-light" onclick="loadAskOffer()">Load Ask Offer</button>
  <button class="btn btn-light" onclick="isAbleToBuy()">Check current buyer</button>
  <button class="btn btn-light" onclick="takePrimaryAskOffer()">Take Primary Ask Offer</button>
  <hr />
  <h3>Manager Approve or Refund Transaction</h3>
  <label>Escrow Transaction ID</label><br />
  <input type="text" class="form-control" id="textEscrowTransactionID"><br />
  <button class="btn btn-light" onclick="listAllEscrowTransaction()">List all escrow transactions</button>
  <button class="btn btn-light" onclick="approveEscrowTransaction()">Approve</button>
  <button class="btn btn-light" onclick="refundEscrowTransaction()">Refund</button>
  <hr />
  <h3>Unfreeze PropertyToken</h3>
  <label>Token addresss</label><br />
  <input type="text" class="form-control" id="textUnfreezePropertyToken"><br />
  <button class="btn btn-light" onclick="unfreezePropertyToken()">Unfreeze PropertyToken</button>
  <hr />
  <h3>Approve & Refund all Escrow Transactions</h3>
  <label>Escrow Transaction IDs (example: 1,2,4,5,6):</label><br />
  <input type="text" class="form-control" id="textListEscrowTransactionID"><br />
  <button class="btn btn-light" onclick="approveAllEscrowTransaction()">Approve All</button>
  <button class="btn btn-light" onclick="refundAllEscrowTransaction()">Refund All</button>
  <pre id="log" style="width: 100%;"></pre>-->
  <script type="text/javascript">
    /*
      var newInterface = null;
      var account = null;
      //New contracts
      var dataLog = "";
      var offerData = null;
      var wl = null;
      var pt = null;
      var es = null;

      //Renew token name
      function renewTokenName() {
        propertyTokenName.value = "RS_PROPERTY_" + (((Math.random() * 0xffffffff) | 0) >>> 0).toString(16);
      }

      //Dev only
      function logData() {
        for (let i = 0; i < arguments.length; i++) {
          if (arguments[i] !== null && typeof (arguments[i]['valueOf']) === 'function') {
            console.log(arguments[i].valueOf());
          } else {
            console.log(arguments[i]);
          }
        }
      }

      //Data log
      function console.log(input) {
        dataLog = input + '\n' + dataLog;
        document.getElementById('log').innerText = dataLog;
      }

      //function primarySell(address _tokenOwner, address _tokenAddress, uint128 _type, uint128 _duration, uint256 _amount, uint256 _price, uint256 _minimum)

      //Runtime check
      if (typeof (window.ContractInterface) !== 'undefined') {

        function isAbleToBuy() {
          if (newInterface === null) return;
          var buyer = newInterface.defaultAccount;
          var offerID = textOfferId.value;
          (async () => {
            let data = await es.sync.offerData(newInterface.toBigNumber(offerID));
            let token = newInterface.load('PropertyToken', data[0]);
            //Is owner verified
            if (await wl.sync.verified(data[1])) {
              console.log('[INFO] Owner was verified');
            } else {
              console.log('[ERROR] Owner wasn\'t verified');
            }
            //Is buyer verified
            if (await wl.sync.verified(buyer)) {
              console.log('[INFO] Buyer was verified');
            } else {
              console.log('[ERROR] Buyer wasn\'t verified');
            }
            //Is PropertyToken verified
            if (await wl.sync.verified(data[0])) {
              console.log('[INFO] PropertyToken was verified');
            } else {
              console.log('[ERROR] PropertyToken wasn\'t verified');
            }
            //Is Exchange verified
            if (await wl.sync.verified(newInterface.contracts.ExchangeStable)) {
              console.log('[INFO] Exchange was verified');
            } else {
              console.log('[ERROR] Exchange wasn\'t verified');
            }
            //Is Escrow verified
            if (await wl.sync.verified(newInterface.contracts.EscrowPayment)) {
              console.log('[INFO] EscrowPayment was verified');
            } else {
              console.log('[ERROR] EscrowPayment wasn\'t verified');
            }
            //Is ProfitPool verified
            if (await wl.sync.verified(await es.sync.profitPool())) {
              console.log('[INFO] ProfitPool was verified');
            } else {
              console.log('[ERROR] ProfitPool wasn\'t verified');
            }
            //Is buyer delegate their StableCoin
            let delegateSC = await sc.sync.allowance(buyer, newInterface.contracts.ExchangeStable);
            if (delegateSC.gt(0)) {
              console.log('[INFO] Buyer was delegate: ' + delegateSC.div('1e+18').valueOf() + ' RUSD');
            } else {
              console.log('[ERROR] Buyer wasn\'t delegate their StableCoin');
            }
            //Is PropertyToken was delegate to exchange
            if ((await token.sync.allowedInternalTransfer(newInterface.contracts.ExchangeStable))) {
              console.log('[INFO] Manager was delegate owner PropertyToken to Exchange');
            }
            else {
              console.log('[ERROR] Manager wasn\'t delegate owner PropertyToken to Exchange');
            }
          })();

        }

        function #btnConnectWallet() {
          (async function () {
            if (newInterface !== null) return;

            //Create new interface of contract
            newInterface = new ContractInterface();
            let network = window.location.hash.substr(1) || 'rinkeby';
            if (network === 'rinkeby') {
              document.getElementById('networkID').innerHTML = "rinkeby: staging";
            } else if (network === 'rinkeby-dev') {
              document.getElementById('networkID').innerHTML = "rinkeby: dev";
            }

            //Init Cotract Interface
            let accounts = await newInterface.init(network);

            if (accounts.length > 0) {
              console.log('Accounts: ' + JSON.stringify(accounts));
              textUserAccount.value = newInterface.defaultAccount;
              textTokenOwner.value = newInterface.defaultAccount;
              //Request for balance
              let balance = await newInterface.getBalance(newInterface.defaultAccount);
              if (balance !== null) {
                textUserBalance.value = balance.div('1e+18').valueOf();
                console.log('Balance in wei: ' + balance.valueOf());
              }
            }

            //Dev only
            wl = newInterface.load('Whitelist');
            pt = newInterface.load('PropertyToken');
            es = newInterface.load('ExchangeStable');
            sc = newInterface.load('StableCoin');
            ep = newInterface.load('EscrowPayment');

            newInterface.registerCallback(function (job, txHash, error, confirmed, result) {
              if (!error) {
                if (confirmed) {
                  let events = newInterface.getEvents(result);
                  console.log('    was confirmed in block: ' + result.blockNumber + " blockhash: " + result.blockHash);
                  console.log('[' + job + '] Transaction ' + result.transactionHash);
                  let txIDs = textListEscrowTransactionID.value
                    .split(',')                                              //Split string to array
                    .map(it => it.trim())                                    //Trim spaces
                    .filter((it, pos, self) => self.indexOf(it) === pos)     //Filter duplicated
                    .map(it => newInterface.toBigNumber(it));                //Convert to big integer
                  console.log(result, events);
                  //All job handler
                  switch (job) {
                    case 'checkTokenizeDone':
                      if (typeof (result.contractAddress) === 'string') {
                        console.log('[SUCCESS] Contract is deployed at ' + result.contractAddress);
                        propertyTokenAddress.value = result.contractAddress;
                        newInterface.unWatch(result.transactionHash);
                      }
                      break;
                    case 'checkWhitelistDone':
                      if (events.filter(i => i.event.contract === 'Whitelist' && i.event.name === 'Add').length > 0) {
                        console.log('[SUCCESS] Event emitted `Whitelist.Add`');
                        newInterface.unWatch(result.transactionHash);
                      }
                      break;
                    case 'checkInternalTransfer':
                      (async function () {
                        let propertyTokenInstance = newInterface.load('PropertyToken', primarySaleTokenAddress.value);
                        if (await propertyTokenInstance.sync.allowedInternalTransfer(newInterface.contracts.ExchangeStable)) {
                          console.log('[SUCCESS] Exchange was allowed to move PropertyToken fund.');
                          newInterface.unWatch(result.transactionHash);
                        }
                      })();
                      break;
                    case 'checkPrimarySell':
                      if (events.filter(i => i.event.contract === 'ExchangeStable' && i.event.name === 'PrimarySell').length > 0) {
                        console.log('[SUCCESS] Event emitted `ExchangeStable.PrimarySell`');
                        newInterface.unWatch(result.transactionHash);
                      }
                      break;
                    case 'checkTakePrimaryAskOffer':
                      if (events.filter(i => i.event.contract === 'ExchangeStable' && i.event.name === 'PrimaryBuy').length > 0) {
                        console.log('[SUCCESS] Event emitted `ExchangeStable.PrimaryBuy`');
                        newInterface.unWatch(result.transactionHash);
                      }
                      break;
                    case 'checkAllowExchangeUseStableCoin':
                      (async function () {
                        let stablecoinInstance = newInterface.load('StableCoin');
                        if ((await stablecoinInstance.sync.allowance(newInterface.defaultAccount, newInterface.contracts.ExchangeStable)).gt(0)) {
                          console.log('[SUCCESS] Exchange was allowed to move StableCoin fund.');
                          newInterface.unWatch(result.transactionHash);
                        }
                      })();
                      break;
                    case 'checkApproveEscrowTransaction':
                      if (events.filter(i => i.event.contract === 'EscrowPayment' && i.event.name === 'Approve').length > 0) {
                        console.log('[SUCCESS] Event emitted `EscrowPayment.Approve`');
                        newInterface.unWatch(result.transactionHash);
                      }
                      break;
                    case 'checkRefundEscrowTransaction':
                      if (events.filter(i => i.event.contract === 'EscrowPayment' && i.event.name === 'Refund').length > 0) {
                        console.log('[SUCCESS] Event emitted `Whitelist.Refund`');
                        newInterface.unWatch(result.transactionHash);
                      }
                      break;
                    case 'checkApproveAllEscrowTransaction':
                      if (events.filter(i => i.event.contract === 'EscrowPayment' && i.event.name === 'Approve').length > 0) {
                        console.log('[SUCCESS] Event emitted `EscrowPayment.Approve(' + events.filter(i => i.event.contract === 'EscrowPayment' && i.event.name === 'Approve').length + ') times`');
                        newInterface.unWatch(result.transactionHash);
                      } else {
                        (async () => {
                          let escrowPaymentInstance = newInterface.load('EscrowPayment');
                          if ((await escrowPaymentInstance.sync.pendingTransactions(txIDs[0]))[5]) {
                            console.log('[SUCCESS] trigger `EscrowPayment.ApproveAll`');
                            newInterface.unWatch(result.transactionHash);
                          }
                        })();
                      }
                      break;
                    case 'checkRefundAllEscrowTransaction':
                      if (events.filter(i => i.event.contract === 'EscrowPayment' && i.event.name === 'Refund').length > 0) {
                        console.log('[SUCCESS] Event emitted `Whitelist.Refund(' + events.filter(i => i.event.contract === 'EscrowPayment' && i.event.name === 'Refund').length + ') times`');
                        newInterface.unWatch(result.transactionHash);
                      } else {
                        (async () => {
                          let escrowPaymentInstance = newInterface.load('EscrowPayment');
                          if ((await escrowPaymentInstance.sync.pendingTransactions(txIDs[0]))[5]) {
                            console.log('[SUCCESS] trigger `EscrowPayment.RefundAll`');
                            newInterface.unWatch(result.transactionHash);
                          }
                        })();
                      }
                      break;
                    case 'checkUnfreezeTransaction':
                      if (events.filter(i => i.event.contract === 'PropertyToken' && i.event.name === 'Unpause').length > 0) {
                        console.log('[SUCCESS] Event emitted `PropertyToken.Unpause`');
                        newInterface.unWatch(result.transactionHash);
                      }
                      break;
                  }
                } else {
                  console.log('[WAIT] Waitting for transaction: ' + txHash + ' to be mined.');
                }
              }
              else {
                console.log('[REJECTED] Transaction: ' + txHash + ' was not confimed: ' + error.message);
              }
            }).watch();
          })();
        }

        function deployPropertyToken() {
          if (newInterface === null) return;
          //Clear old data
          propertyTokenAddress.value = '';
          //Trigger deploy method
          return newInterface.deployPropertyToken(newInterface.defaultAccount, //Deployer
            textTokenOwner.value, //Owner
            newInterface.utilities.scenarios.PROPERTY_TOKEN_SCENARIO_ALL,
            newInterface.contracts.Whitelist,
            function (err, newPropertyToken) {
              if (!err) {
                if (typeof (newPropertyToken.address) === 'undefined') {
                  renewTokenName();
                  console.log('Deploy PropertyToken in transaction: ' + newPropertyToken.transactionHash.valueOf());
                  newInterface.registerTx('checkTokenizeDone', newPropertyToken.transactionHash.valueOf()).watch();
                }
              }
            });
        }

        function whitelistAnAddress() {
          if (newInterface === null) return;
          if (!newInterface.utilities.isValidAddress(propertyTokenAddress.value)) {
            console.log('Invalid address to whitelist.');
            return;
          }
          let whitelistInstance = newInterface.load('Whitelist');
          (async function () {
            if (await whitelistInstance.sync.verified(propertyTokenAddress.value)) {
              console.log('Address is whitelisted');
              return;
            }
            //Trigger Whitelist.add(bytes32 _name, addres _address);
            whitelistInstance.add(propertyTokenName.value, propertyTokenAddress.value, function (err, transactionHash) {
              if (!err) {
                console.log('Add PropertyToken to Whitelist at: ' + transactionHash.valueOf());
                newInterface.registerTx('checkWhitelistDone', transactionHash.valueOf()).watch();
                renewTokenName();
              }
            });
          })();
        }

        function readWhitelist() {
          (async function () {
            if (newInterface === null) return;
            let whitelistInstance = newInterface.load('Whitelist');
            let total = await whitelistInstance.sync.totalVerified();
            let totalVerified = total.toNumber();
            console.log('Read 5 latest records from Whitelist');
            for (let i = ((totalVerified - 5) < 0) ? 0 : (totalVerified - 5); i < totalVerified; i++) {
              let name = await whitelistInstance.sync.ordering(i);
              let address = await whitelistInstance.sync.addressBook(name);
              let verified = await whitelistInstance.sync.verified(address);
              console.log([
                i,
                newInterface.utilities.bytesToString(name.valueOf()),
                address.valueOf(),
                verified.valueOf()
              ].join('    '));
            }
            console.log('No    Token Name                         Token Address                                 Verified');
          })();
        }

        function allowInternalTransfer() {
          if (newInterface === null) return;
          if (!newInterface.utilities.isValidAddress(primarySaleTokenAddress.value)) {
            console.log('Invalid PropertyToken address');
            return;
          }
          (async function () {
            let propertyTokenInstance = newInterface.load('PropertyToken', primarySaleTokenAddress.value);
            //Is exchange able to use fund
            let allowed = await propertyTokenInstance.sync.allowedInternalTransfer(newInterface.contracts.ExchangeStable);
            console.log('Is exchange able to use PropertyToken fund? ' + allowed.valueOf());
            if (!allowed) {
              propertyTokenInstance.allowInternalTransfer(newInterface.contracts.ExchangeStable, function (err, transactionHash) {
                if (!err) {
                  console.log('Allow exchange use PropretyToken at: ' + transactionHash.valueOf());
                  newInterface.registerTx('checkInternalTransfer', transactionHash.valueOf()).watch();
                  renewTokenName();
                }
              });
            }
          })();
        }

        function allowExchangeUseStableCoin() {
          if (newInterface === null) return;
          (async function () {
            let stablecoinInstance = newInterface.load('StableCoin');
            stablecoinInstance.approve(newInterface.contracts.ExchangeStable, newInterface.toBigNumber(textAmountStableCoin.value).mul('1e+18'), function (err, transactionHash) {
              if (!err) {
                console.log('Allow exchange use PropretyToken at: ' + transactionHash.valueOf());
                newInterface.registerTx('checkAllowExchangeUseStableCoin', transactionHash.valueOf()).watch();
                renewTokenName();
              }
            });
          })();
        }

        function startPrimarySale() {
          if (newInterface === null) return;
          (async function () {
            if (!newInterface.utilities.isValidAddress(primarySaleTokenAddress.value)) {
              console.log('Invalid PropertyToken address');
              return;
            }
            let propertyTokenInstance = newInterface.load('PropertyToken', primarySaleTokenAddress.value);
            //Is exchange able to use fund
            let allowed = await propertyTokenInstance.sync.allowedInternalTransfer(newInterface.contracts.ExchangeStable);
            console.log('Is exchange able to use PropertyToken fund? ' + allowed.valueOf());
            if (allowed) {
              let exchangeStableInstance = newInterface.load('ExchangeStable');
              exchangeStableInstance.primarySell(textTokenOwner.value,                            //Property owner
                primarySaleTokenAddress.value,                                                  //Property token
                newInterface.utilities.createOfferType({                                        //Offer type
                  ask: true,
                  whole: false,
                  available: true,
                  primary: true
                }),
                259200,                                             //Duration 3 days in secs
                1000000,                                            //Amount
                newInterface.toBigNumber("0.12").mul("1e+18"),      //Price $0.12
                1000,
                function (err, transactionHash) {
                  if (!err) {
                    console.log('Start pimary sale at: ' + transactionHash.valueOf());
                    newInterface.registerTx('checkPrimarySell', transactionHash.valueOf()).watch();
                    renewTokenName();
                  }
                });                                      //Minimum
            } else {
              console.log('Please allow exchange to move fund first.');
            }
          })();
        }

        function loadAskOffer() {
          if (newInterface === null) return;
          (async function () {
            let exchangeInstance = newInterface.load('ExchangeStable');
            offerData = await exchangeInstance.sync.offerData(newInterface.toBigNumber(textOfferId.value));
            console.log('        Token      :    ' + offerData[0]);
            console.log('        Maker      :    ' + offerData[1]);
            console.log('        oType      :    ' + JSON.stringify(newInterface.utilities.getOfferType(offerData[2].valueOf())));
            console.log('        Expired    :    ' + newInterface.utilities.timeConverter(offerData[3].valueOf()));
            console.log('        Amount     :    ' + offerData[4].valueOf());
            console.log('        Minium     :    ' + offerData[5].valueOf());
            console.log('        Price      :    ' + offerData[6].valueOf() + ' ($' + offerData[6].div('1e+18') + ')');
            console.log('Offer ID: ' + textOfferId.value);
          })();
        }

        function onChangeAmount() {
          if (newInterface === null || offerData === null) return;
          let amount = newInterface.toBigNumber(textAmount.value);
          document.getElementById('estimated').innerHTML = '$' + amount.mul(offerData[6]).div('1e+18');
        }

        function takePrimaryAskOffer() {
          if (newInterface === null || offerData === null) return;
          (async function () {
            let whitelistInstance = newInterface.load('Whitelist');
            let exchangeInstance = newInterface.load('ExchangeStable');
            let stablecoinInstance = newInterface.load('StableCoin');
            let amount = newInterface.toBigNumber(textAmount.value);
            document.getElementById('estimated').innerHTML = '$' + amount.mul(offerData[6]).div('1e+18');
            if (!(await whitelistInstance.sync.verified(newInterface.defaultAccount)).valueOf()) {
              console.log(newInterface.defaultAccount + ' was not verified.');
              return;
            }
            exchangeInstance.primaryBuy(newInterface.toBigNumber(textOfferId.value), amount, function (err, transactionHash) {
              if (!err) {
                console.log('Take primary ask offer: ' + transactionHash.valueOf());
                newInterface.registerTx('checkTakePrimaryAskOffer', transactionHash.valueOf()).watch();
              }
            });
          })();
        }

        function listAllEscrowTransaction() {
          if (newInterface === null) return;
          (async function () {
            let escrowInstance = newInterface.load('EscrowPayment');
            let totalTransaction = await escrowInstance.sync.totalTransaction();
            //BigNumber to number
            let totalTx = totalTransaction.toNumber();
            console.log('Load 5 latest escrow transactions');
            for (let i = ((totalTx - 5) < 0) ? 0 : (totalTx - 5); i < totalTx; i++) {
              //Get escrow transaction
              let data = await escrowInstance.sync.pendingTransactions(i);
              console.log('    Executed:' + data[5].valueOf());
              console.log('    Fee:' + data[4].valueOf());
              console.log('    Value:' + data[3].valueOf());
              console.log('    To:' + data[2]);
              console.log('    From:' + data[1]);
              console.log('    Token:' + data[0]);
              console.log('Transaction: #' + i);
            }
          })();
        }

        function approveEscrowTransaction() {
          if (newInterface === null) return;
          let escrowInstance = newInterface.load('EscrowPayment');
          escrowInstance.approve(newInterface.toBigNumber(textEscrowTransactionID.value), function (err, transactionHash) {
            if (!err) {
              console.log('Approve escrow transaction: ' + transactionHash.valueOf());
              newInterface.registerTx('checkApproveEscrowTransaction', transactionHash.valueOf()).watch();
            }
          });
        }

        function refundEscrowTransaction() {
          if (newInterface === null) return;
          let escrowInstance = newInterface.load('EscrowPayment');
          escrowInstance.refund(newInterface.toBigNumber(textEscrowTransactionID.value), function (err, transactionHash) {
            if (!err) {
              console.log('Refund escrow transaction: ' + transactionHash.valueOf());
              newInterface.registerTx('checkRefundEscrowTransaction', transactionHash.valueOf()).watch();
            }
          });
        }

        function unfreezePropertyToken() {
          (async () => {
            if (newInterface === null) return;
            let propertyTokenInstance = newInterface.load('PropertyToken', textUnfreezePropertyToken.value);
            if (!await propertyTokenInstance.sync.paused()) {
              console.log('PropertyToken was not paused');
              return;
            }
            propertyTokenInstance.unpause(function (err, transactionHash) {
              if (!err) {
                console.log('Unfreeze PropertyToken at (' + textUnfreezePropertyToken.value + ') : ' + transactionHash.valueOf());
                newInterface.registerTx('checkUnfreezeTransaction', transactionHash.valueOf()).watch();
              }
            });
          })();
        }

        function approveAllEscrowTransaction() {
          if (newInterface === null) return;
          let escrowInstance = newInterface.load('EscrowPayment');
          let txIDs = textListEscrowTransactionID.value
            .split(',')                                              //Split string to array
            .map(it => it.trim())                                    //Trim spaces
            .filter((it, pos, self) => self.indexOf(it) === pos)     //Filter duplicated
            .map(it => newInterface.toBigNumber(it));                //Convert to big integer
          escrowInstance.approveAll(txIDs, function (err, transactionHash) {
            if (!err) {
              console.log('Approve all escrow transactions: ' + transactionHash.valueOf());
              newInterface.registerTx('checkApproveAllEscrowTransaction', transactionHash.valueOf()).watch();
            }
          });
        }

        function refundAllEscrowTransaction() {
          if (newInterface === null) return;
          let escrowInstance = newInterface.load('EscrowPayment', newInterface.contracts.EscrowPayment);
          let txIDs = textListEscrowTransactionID.value
            .split(',')                                              //Split string to array
            .map(it => it.trim())                                    //Trim spaces
            .filter((it, pos, self) => self.indexOf(it) === pos)     //Filter duplicated
            .map(it => newInterface.toBigNumber(it));                //Convert to big integer
          escrowInstance.refundAll(txIDs, function (err, transactionHash) {
            if (!err) {
              console.log('Refund all escrow transactions: ' + transactionHash.valueOf());
              newInterface.registerTx('checkRefundAllEscrowTransaction', transactionHash.valueOf()).watch();
            }
          });
        }

        renewTokenName();
        #btnConnectWallet();
      } else {
        throw new Error('Contract interface was not loaded');
      }
      */
  </script>
</body>

</html>