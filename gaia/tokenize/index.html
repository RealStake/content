<html>

<head>
    <title>Contract Interface</title>
    <style>
        * {
            margin: 5px;
        }
        input {
            padding: 5px;
            border: 1px solid gray;
        }
    </style>
</head>

<body>
    <script type="text/javascript" src="./js/main.js"></script>
    <label>User account:</label><br />
    <input id="textUserAccount" size="40"><br />
    <label>Ethereum balance:</label><br />
    <input id="textUserBalance" size="40"><br />
    <button onclick="connectWallet()">Connect Wallet</button>
    <button onclick="deployPropertyToken()">Deploy</button><br />
    <br />
    <label>Unique name:</label><br />
    <input id="propertyTokenName" size="40"><br />
    <label>PropertyToken's address:</label><br />
    <input id="propertyTokenAddress" size="40"><br />
    <button onclick="whitelistPropertyToken()">Whitelist</button>
    <button onclick="isWhitelist()">Is Whitelisted ?</button><br />
    <pre id="log" style="width: 100%;"></pre>
    <script type="text/javascript">
        var newInterface = null;
        var account = null;
        var EscrowPayment = "0x4779283df0ad68da174d4e15a9d33589d6e566ff";
        var ExchangeStable = "0x3720e2f957ebf5c3915f63bfa4ac482c461ebecf";
        var StableCoin = "0x1f3171d1f5100e4386ca5c7ec0b2bfda595dd4f1";
        var Whitelist = "0x901c8d90e66b759b08b200088391e524389d8371";
        var dataLog = "";

        //Renew token name
        function renewTokenName() {
            propertyTokenName.value = "RS_PROPERTY_" + (((Math.random() * 0xffffffff) | 0) >>> 0).toString(16);
        }

        //Data log
        function logMe(input) {
            dataLog += input + '\n';
            document.getElementById('log').innerText = dataLog;
        }

        //Runtime check
        if (typeof (window.ContractInterface) !== 'undefined') {
            function connectWallet() {
                if (newInterface !== null) return;
                //Create new Contract Interface
                newInterface = new ContractInterface();
                //Init contract interface
                newInterface.init((error, value) => {
                    if (!error) {
                        logMe('Accounts: ' + JSON.stringify(value));
                        textUserAccount.value = value[0];
                        account = value[0];
                        newInterface.getBalance(value[0], (err, value) => {
                            if (!err) {
                                logMe('Balance in wei: ' + value.valueOf());
                                textUserBalance.value = value.div('1e+18').valueOf();
                            }
                        });
                        //Register callbacks to handle transaction confirmation
                        newInterface.registerCallbacks({
                            checkWhitelistDone: function (error, confirmed, result) {
                                if (!error) {
                                    if (confirmed) {
                                        logMe('Whitelist transcation was confirmed in block: ' + result.blockNumber + " blockhash: " + result.blockHash);
                                        console.log(result);
                                    } else {
                                        logMe('Waiting for whitelist transaction to be mined.');
                                    }
                                }
                                else {
                                    logMe('Token whitelist failed: ' + error.message);
                                }
                            },
                            checkTokenizeDone: function (error, confirmed, result) {
                                if (!error) {
                                    if (confirmed) {
                                        logMe('Tokenize transcation was confirmed in block: ' + result.blockNumber + " blockhash: " + result.blockHash);
                                        console.log(result);
                                        if (typeof (result.contractAddress) !== 'undefined') {
                                            logMe('[Double check]PropertyToken deployed at: ' + result.contractAddress.valueOf());
                                            propertyTokenAddress.value = result.contractAddress.valueOf();
                                            renewTokenName();
                                        }
                                    } else {
                                        logMe('Waiting for tokenize transaction to be mined.');
                                    }
                                }
                                else {
                                    logMe('Tokenize failed: ' + error.message);
                                }
                            }
                        }).watch();
                    }
                });
            }

            function deployPropertyToken() {
                if (newInterface === null) return;
                //Clear old data
                propertyTokenAddress.value = '';
                //Trigger deploy method
                return newInterface.deployPropertyToken(account,
                    account,
                    newInterface.utilities.scenarios.PROPERTY_TOKEN_SCENARIO_ALL,
                    Whitelist,
                    function (err, newPropertyToken) {
                        if (!err) {
                            if (typeof (newPropertyToken.address) === 'undefined') {
                                renewTokenName();
                                logMe('Deploy PropertyToken in transaction: ' + newPropertyToken.transactionHash.valueOf());
                                newInterface.registerTx('checkTokenizeDone', newPropertyToken.transactionHash.valueOf()).watch();
                            } else {
                                logMe('PropertyToken deployed at: ' + newPropertyToken.address.valueOf());
                                propertyTokenAddress.value = newPropertyToken.address.valueOf();
                            }
                        }
                    });
            }

            function whitelistPropertyToken() {
                if (newInterface === null) return;
                let whitelistInstance = newInterface.load('Whitelist', Whitelist);
                renewTokenName();
                //Trigger Whitelist.add(bytes32 _name, addres _address);
                whitelistInstance.add(propertyTokenName.value, propertyTokenAddress.value, function (err, transactionHash) {
                    if (!err) {
                        logMe('Add PropertyToken to Whitelist at: ' + transactionHash.valueOf());
                        newInterface.registerTx('checkWhitelistDone', transactionHash.valueOf()).watch();
                        renewTokenName();
                    }
                });
            }

            function isWhitelist() {
                if (newInterface === null) return;
                let whitelistInstance = newInterface.load('Whitelist', Whitelist);
                whitelistInstance.verified(propertyTokenAddress.value, function (err, result) {
                    if (!err) {
                        logMe('Is PropertyToken at (' + propertyTokenAddress.value + ') whitelisted : ' + result.valueOf());
                    }
                });
            }

            renewTokenName();
            connectWallet();

        } else {
            throw new Error('Contract interface was not loaded');
        }
    </script>
</body>

</html>